const a="/api",h=[{label:"1H",hours:1},{label:"6H",hours:6},{label:"24H",hours:24},{label:"7D",hours:168},{label:"30D",hours:720},{label:"All",hours:0}];async function f(t,e,n){const s=new URLSearchParams;s.append("limit","5000"),e!==void 0&&e>0&&s.append("hours",String(e)),n!==void 0&&s.append("batch_id",String(n));const o=await fetch(`${a}/devices/${t}/readings?${s}`);if(!o.ok)throw new Error(`Failed to fetch readings: ${o.statusText}`);return o.json()}async function p(t=24){const e=await fetch(`${a}/ambient/history?hours=${t}`);if(!e.ok)throw new Error("Failed to fetch ambient history");return e.json()}async function d(t=24){const e=await fetch(`${a}/chamber/history?hours=${t}`);if(!e.ok)throw new Error("Failed to fetch chamber history");return e.json()}async function u(t){const e=await fetch(`${a}/batches/${t}/predictions`);if(!e.ok)throw new Error(`Failed to fetch batch predictions: ${e.statusText}`);return e.json()}async function w(t){const e=await fetch(`${a}/batches/${t}/reload-predictions`,{method:"POST"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to reload predictions")}return e.json()}async function l(){const t=await fetch(`${a}/control/heater-entities`);if(!t.ok)throw new Error(`Failed to fetch heater entities: ${t.statusText}`);return t.json()}async function y(){const t=await fetch(`${a}/control/cooler-entities`);if(!t.ok)throw new Error(`Failed to fetch cooler entities: ${t.statusText}`);return t.json()}async function m(t){const e=await fetch(`${a}/control/batch/${t}/status`);if(!e.ok)throw new Error(`Failed to fetch batch control status: ${e.statusText}`);return e.json()}async function $(t,e,n=60,s="heater"){return(await fetch(`${a}/control/override`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({state:e,duration_minutes:n,batch_id:t,device_type:s})})).json()}async function c(t,e,n=50,s=0,o=!1){const r=new URLSearchParams;o&&r.append("deleted_only","true"),r.append("limit",String(n)),r.append("offset",String(s));const i=await fetch(`${a}/batches?${r}`);if(!i.ok)throw new Error(`Failed to fetch batches: ${i.statusText}`);return i.json()}async function T(t=50,e=0){const n=new URLSearchParams;n.append("limit",String(t)),n.append("offset",String(e));const s=await fetch(`${a}/batches/active?${n}`);if(!s.ok)throw new Error(`Failed to fetch active batches: ${s.statusText}`);return s.json()}async function j(t=50,e=0){const n=new URLSearchParams;n.append("limit",String(t)),n.append("offset",String(e));const s=await fetch(`${a}/batches/completed?${n}`);if(!s.ok)throw new Error(`Failed to fetch completed batches: ${s.statusText}`);return s.json()}async function E(t=50,e=0){return c(void 0,void 0,t,e,!0)}async function b(t){const e=await fetch(`${a}/batches/${t}`);if(!e.ok)throw new Error(`Failed to fetch batch: ${e.statusText}`);return e.json()}async function S(t){const e=await fetch(`${a}/batches`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create batch: ${e.statusText}`);return e.json()}async function x(t,e){const n=await fetch(`${a}/batches/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok)throw new Error(`Failed to update batch: ${n.statusText}`);return n.json()}async function F(t,e=!1){const n=`${a}/batches/${t}/delete`,s=e?`${n}?hard_delete=true`:n,o=await fetch(s,{method:"POST"});if(!o.ok)throw new Error(`Failed to delete batch: ${o.statusText}`)}async function k(t){const e=await fetch(`${a}/batches/${t}/restore`,{method:"POST"});if(!e.ok)throw new Error(`Failed to restore batch: ${e.statusText}`);return e.json()}async function v(t){const e=await fetch(`${a}/batches/${t}/progress`);if(!e.ok)throw new Error(`Failed to fetch batch progress: ${e.statusText}`);return e.json()}async function g(t=50,e=0){const n=await fetch(`${a}/recipes?limit=${t}&offset=${e}`);if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to fetch recipes")}return n.json()}async function P(t){const e=await fetch(`${a}/recipes/${t}`);if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to fetch recipe")}return e.json()}async function O(t){const e=await fetch(`${a}/recipes`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText})),s=Array.isArray(n.detail)?n.detail.join("; "):n.detail;throw new Error(s||"Failed to create recipe")}return e.json()}async function C(t,e){const n=await fetch(`${a}/recipes/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText})),o=Array.isArray(s.detail)?s.detail.join("; "):s.detail;throw new Error(o||"Failed to update recipe")}return n.json()}async function _(t){const e=new FormData;e.append("file",t);const n=await fetch(`${a}/recipes/import`,{method:"POST",body:e});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText})),o=Array.isArray(s.detail)?s.detail.join("; "):s.detail;throw new Error(o||"Failed to import recipe")}return n.json()}async function R(t){const e=await fetch(`${a}/recipes/${t}`,{method:"DELETE"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to delete recipe")}}async function H(){const t=await fetch(`${a}/maintenance/orphaned-data`);if(!t.ok)throw new Error(`Failed to fetch orphaned data: ${t.statusText}`);return t.json()}async function L(t){const e=await fetch(`${a}/maintenance/cleanup-readings`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({deleted_batch_ids:t,dry_run:!0})});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to preview cleanup")}return e.json()}async function N(t){const e=await fetch(`${a}/maintenance/cleanup-readings`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({deleted_batch_ids:t,dry_run:!1})});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to execute cleanup")}return e.json()}async function J(t,e=24){const n=await fetch(`${a}/batches/${t}/control-events?hours=${e}`);if(!n.ok)throw new Error(`Failed to fetch control events: ${n.statusText}`);return n.json()}async function A(t,e=!1){const n=new URLSearchParams;e&&n.append("include_cleared","true");const s=await fetch(`${a}/batches/${t}/alerts?${n}`);if(!s.ok)throw new Error(`Failed to fetch batch alerts: ${s.statusText}`);return s.json()}async function U(t,e){const n=await fetch(`${a}/batches/${t}/alerts/${e}/dismiss`,{method:"POST"});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to dismiss alert")}return n.json()}async function B(t){const e=await fetch(`${a}/batches/${t}/alerts/dismiss-all`,{method:"POST"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to dismiss alerts")}return e.json()}async function q(t){const e=new URLSearchParams;t?.type&&e.append("type",t.type),t?.producer&&e.append("producer",t.producer),t?.form&&e.append("form",t.form),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/yeast-strains?${e}`);if(!n.ok)throw new Error(`Failed to fetch yeast strains: ${n.statusText}`);return n.json()}async function D(){const t=await fetch(`${a}/yeast-strains/producers`);if(!t.ok)throw new Error(`Failed to fetch yeast producers: ${t.statusText}`);return t.json()}async function Y(t){const e=await fetch(`${a}/yeast-strains`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create yeast strain: ${e.statusText}`);return e.json()}async function I(t){const e=await fetch(`${a}/yeast-strains/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete yeast strain: ${e.statusText}`)}async function V(){const t=await fetch(`${a}/yeast-strains/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh yeast strains: ${t.statusText}`);return t.json()}async function M(t){const e=new URLSearchParams;t?.origin&&e.append("origin",t.origin),t?.purpose&&e.append("purpose",t.purpose),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/hop-varieties?${e}`);if(!n.ok)throw new Error(`Failed to fetch hop varieties: ${n.statusText}`);return n.json()}async function G(){const t=await fetch(`${a}/hop-varieties/origins`);if(!t.ok)throw new Error(`Failed to fetch hop origins: ${t.statusText}`);return t.json()}async function W(t){const e=await fetch(`${a}/hop-varieties`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create hop variety: ${e.statusText}`);return e.json()}async function z(t){const e=await fetch(`${a}/hop-varieties/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete hop variety: ${e.statusText}`)}async function K(){const t=await fetch(`${a}/hop-varieties/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh hop varieties: ${t.statusText}`);return t.json()}async function Q(t){const e=new URLSearchParams;t?.type&&e.append("type",t.type),t?.origin&&e.append("origin",t.origin),t?.maltster&&e.append("maltster",t.maltster),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/fermentables?${e}`);if(!n.ok)throw new Error(`Failed to fetch fermentables: ${n.statusText}`);return n.json()}async function X(){const t=await fetch(`${a}/fermentables/types`);if(!t.ok)throw new Error(`Failed to fetch fermentable types: ${t.statusText}`);return t.json()}async function Z(){const t=await fetch(`${a}/fermentables/origins`);if(!t.ok)throw new Error(`Failed to fetch fermentable origins: ${t.statusText}`);return t.json()}async function tt(){const t=await fetch(`${a}/fermentables/maltsters`);if(!t.ok)throw new Error(`Failed to fetch maltsters: ${t.statusText}`);return t.json()}async function et(t){const e=await fetch(`${a}/fermentables`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create fermentable: ${e.statusText}`);return e.json()}async function nt(t){const e=await fetch(`${a}/fermentables/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete fermentable: ${e.statusText}`)}async function at(){const t=await fetch(`${a}/fermentables/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh fermentables: ${t.statusText}`);return t.json()}async function st(t){const e=new URLSearchParams,n=await fetch(`${a}/inventory/equipment?${e}`);if(!n.ok)throw new Error(`Failed to fetch equipment: ${n.statusText}`);return n.json()}async function ot(t){const e=await fetch(`${a}/inventory/equipment`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create equipment")}return e.json()}async function rt(t,e){const n=await fetch(`${a}/inventory/equipment/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update equipment")}return n.json()}async function it(t){const e=await fetch(`${a}/inventory/equipment/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete equipment: ${e.statusText}`)}async function ct(t){const e=new URLSearchParams,n=await fetch(`${a}/inventory/hops?${e}`);if(!n.ok)throw new Error(`Failed to fetch hop inventory: ${n.statusText}`);return n.json()}async function ht(){const t=await fetch(`${a}/inventory/hops/summary`);if(!t.ok)throw new Error(`Failed to fetch hop summary: ${t.statusText}`);return t.json()}async function ft(t){const e=await fetch(`${a}/inventory/hops`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create hop inventory")}return e.json()}async function pt(t,e){const n=await fetch(`${a}/inventory/hops/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update hop inventory")}return n.json()}async function dt(t,e){const n=await fetch(`${a}/inventory/hops/${t}/adjust`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({delta_grams:e})});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to adjust hop amount")}return n.json()}async function ut(t){const e=await fetch(`${a}/inventory/hops/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete hop: ${e.statusText}`)}async function wt(t){const e=new URLSearchParams;t?.query&&e.append("query",t.query),t?.form&&e.append("form",t.form),t?.include_expired!==void 0&&e.append("include_expired",String(t.include_expired)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/inventory/yeast?${e}`);if(!n.ok)throw new Error(`Failed to fetch yeast inventory: ${n.statusText}`);return n.json()}async function lt(t=30){const e=await fetch(`${a}/inventory/yeast/expiring-soon?days=${t}`);if(!e.ok)throw new Error(`Failed to fetch expiring yeast: ${e.statusText}`);return e.json()}async function yt(){const t=await fetch(`${a}/inventory/yeast/summary`);if(!t.ok)throw new Error(`Failed to fetch yeast summary: ${t.statusText}`);return t.json()}async function mt(t){const e=await fetch(`${a}/inventory/yeast`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create yeast inventory")}return e.json()}async function $t(t,e){const n=await fetch(`${a}/inventory/yeast/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update yeast inventory")}return n.json()}async function Tt(t,e=1){const n=await fetch(`${a}/inventory/yeast/${t}/use`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({quantity:e})});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to use yeast")}return n.json()}async function jt(t){const e=await fetch(`${a}/inventory/yeast/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete yeast: ${e.statusText}`)}async function Et(t){const e=await fetch(`${a}/assistant/review-recipe`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to review recipe")}return e.json()}async function bt(t,e=10){const n=new URLSearchParams;n.append("q",t),n.append("limit",String(e));const s=await fetch(`${a}/recipes/styles/search?${n}`);if(!s.ok)throw new Error(`Failed to search styles: ${s.statusText}`);return s.json()}export{p as $,X as A,tt as B,Y as C,W as D,et as E,I as F,z as G,nt as H,_ as I,H as J,L as K,N as L,E as M,j as N,T as O,v as P,k as Q,F as R,g as S,l as T,y as U,J as V,x as W,c as X,h as Y,b as Z,f as _,ct as a,d as a0,P as a1,C as a2,R as a3,Z as a4,bt as a5,Et as a6,O as a7,w as a8,u as a9,A as aa,U as ab,B as ac,m as ad,$ as ae,ht as b,wt as c,yt as d,lt as e,st as f,q as g,M as h,ot as i,pt as j,ft as k,dt as l,$t as m,mt as n,it as o,ut as p,jt as q,Tt as r,S as s,V as t,rt as u,K as v,at as w,D as x,G as y,Q as z};
