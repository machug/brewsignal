const a="/api",h=[{label:"1H",hours:1},{label:"6H",hours:6},{label:"24H",hours:24},{label:"7D",hours:168},{label:"30D",hours:720},{label:"All",hours:0}];async function f(t,e){const n=new URLSearchParams;n.append("limit","5000"),e!==void 0&&e>0&&n.append("hours",String(e));const s=await fetch(`${a}/batches/${t}/readings?${n}`);if(!s.ok)throw new Error(`Failed to fetch batch readings: ${s.statusText}`);return s.json()}async function p(t=24){const e=await fetch(`${a}/ambient/history?hours=${t}`);if(!e.ok)throw new Error("Failed to fetch ambient history");return e.json()}async function d(t=24){const e=await fetch(`${a}/chamber/history?hours=${t}`);if(!e.ok)throw new Error("Failed to fetch chamber history");return e.json()}async function u(t,e="auto"){const n=new URLSearchParams;e&&e!=="auto"&&n.append("model",e);const s=n.toString(),o=s?`${a}/batches/${t}/predictions?${s}`:`${a}/batches/${t}/predictions`,r=await fetch(o);if(!r.ok)throw new Error(`Failed to fetch batch predictions: ${r.statusText}`);return r.json()}async function w(t){const e=await fetch(`${a}/batches/${t}/reload-predictions`,{method:"POST"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to reload predictions")}return e.json()}async function l(){const t=await fetch(`${a}/control/heater-entities`);if(!t.ok)throw new Error(`Failed to fetch heater entities: ${t.statusText}`);return t.json()}async function y(){const t=await fetch(`${a}/control/cooler-entities`);if(!t.ok)throw new Error(`Failed to fetch cooler entities: ${t.statusText}`);return t.json()}async function $(t){const e=await fetch(`${a}/control/batch/${t}/status`);if(!e.ok)throw new Error(`Failed to fetch batch control status: ${e.statusText}`);return e.json()}async function m(t,e,n=60,s="heater"){return(await fetch(`${a}/control/override`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({state:e,duration_minutes:n,batch_id:t,device_type:s})})).json()}async function c(t,e,n=50,s=0,o=!1){const r=new URLSearchParams;o&&r.append("deleted_only","true"),r.append("limit",String(n)),r.append("offset",String(s));const i=await fetch(`${a}/batches?${r}`);if(!i.ok)throw new Error(`Failed to fetch batches: ${i.statusText}`);return i.json()}async function T(t=50,e=0){const n=new URLSearchParams;n.append("limit",String(t)),n.append("offset",String(e));const s=await fetch(`${a}/batches/active?${n}`);if(!s.ok)throw new Error(`Failed to fetch active batches: ${s.statusText}`);return s.json()}async function j(t=50,e=0){const n=new URLSearchParams;n.append("limit",String(t)),n.append("offset",String(e));const s=await fetch(`${a}/batches/completed?${n}`);if(!s.ok)throw new Error(`Failed to fetch completed batches: ${s.statusText}`);return s.json()}async function E(t=50,e=0){return c(void 0,void 0,t,e,!0)}async function b(t){const e=await fetch(`${a}/batches/${t}`);if(!e.ok)throw new Error(`Failed to fetch batch: ${e.statusText}`);return e.json()}async function S(t){const e=await fetch(`${a}/batches`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create batch: ${e.statusText}`);return e.json()}async function g(t,e){const n=await fetch(`${a}/batches/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok)throw new Error(`Failed to update batch: ${n.statusText}`);return n.json()}async function x(t,e=!1){const n=`${a}/batches/${t}/delete`,s=e?`${n}?hard_delete=true`:n,o=await fetch(s,{method:"POST"});if(!o.ok)throw new Error(`Failed to delete batch: ${o.statusText}`)}async function F(t){const e=await fetch(`${a}/batches/${t}/restore`,{method:"POST"});if(!e.ok)throw new Error(`Failed to restore batch: ${e.statusText}`);return e.json()}async function k(t,e){const n=await fetch(`${a}/batches/${t}/tasting-notes`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok)throw new Error(`Failed to create tasting note: ${n.statusText}`);return n.json()}async function v(t,e,n){const s=await fetch(`${a}/batches/${t}/tasting-notes/${e}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!s.ok)throw new Error(`Failed to update tasting note: ${s.statusText}`);return s.json()}async function P(t,e){const n=await fetch(`${a}/batches/${t}/tasting-notes/${e}`,{method:"DELETE"});if(!n.ok)throw new Error(`Failed to delete tasting note: ${n.statusText}`)}async function O(t){const e=await fetch(`${a}/batches/${t}/progress`);if(!e.ok)throw new Error(`Failed to fetch batch progress: ${e.statusText}`);return e.json()}async function C(t=50,e=0){const n=await fetch(`${a}/recipes?limit=${t}&offset=${e}`);if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to fetch recipes")}return n.json()}async function _(t){const e=await fetch(`${a}/recipes/${t}`);if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to fetch recipe")}return e.json()}async function N(t){const e=await fetch(`${a}/recipes`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText})),s=Array.isArray(n.detail)?n.detail.join("; "):n.detail;throw new Error(s||"Failed to create recipe")}return e.json()}async function R(t,e){const n=await fetch(`${a}/recipes/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText})),o=Array.isArray(s.detail)?s.detail.join("; "):s.detail;throw new Error(o||"Failed to update recipe")}return n.json()}async function L(t){const e=new FormData;e.append("file",t);const n=await fetch(`${a}/recipes/import`,{method:"POST",body:e});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText})),o=Array.isArray(s.detail)?s.detail.join("; "):s.detail;throw new Error(o||"Failed to import recipe")}return n.json()}async function J(t){const e=await fetch(`${a}/recipes/${t}`,{method:"DELETE"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to delete recipe")}}async function H(){const t=await fetch(`${a}/maintenance/orphaned-data`);if(!t.ok)throw new Error(`Failed to fetch orphaned data: ${t.statusText}`);return t.json()}async function U(t){const e=await fetch(`${a}/maintenance/cleanup-readings`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({deleted_batch_ids:t,dry_run:!0})});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to preview cleanup")}return e.json()}async function A(t){const e=await fetch(`${a}/maintenance/cleanup-readings`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({deleted_batch_ids:t,dry_run:!1})});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to execute cleanup")}return e.json()}async function B(t,e=24){const n=await fetch(`${a}/batches/${t}/control-events?hours=${e}`);if(!n.ok)throw new Error(`Failed to fetch control events: ${n.statusText}`);return n.json()}async function q(t,e=!1){const n=new URLSearchParams;e&&n.append("include_cleared","true");const s=await fetch(`${a}/batches/${t}/alerts?${n}`);if(!s.ok)throw new Error(`Failed to fetch batch alerts: ${s.statusText}`);return s.json()}async function D(t,e){const n=await fetch(`${a}/batches/${t}/alerts/${e}/dismiss`,{method:"POST"});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to dismiss alert")}return n.json()}async function Y(t){const e=await fetch(`${a}/batches/${t}/alerts/dismiss-all`,{method:"POST"});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to dismiss alerts")}return e.json()}async function I(t){const e=new URLSearchParams;t?.type&&e.append("type",t.type),t?.producer&&e.append("producer",t.producer),t?.form&&e.append("form",t.form),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/yeast-strains?${e}`);if(!n.ok)throw new Error(`Failed to fetch yeast strains: ${n.statusText}`);return n.json()}async function V(){const t=await fetch(`${a}/yeast-strains/producers`);if(!t.ok)throw new Error(`Failed to fetch yeast producers: ${t.statusText}`);return t.json()}async function M(t){const e=await fetch(`${a}/yeast-strains`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create yeast strain: ${e.statusText}`);return e.json()}async function G(t){const e=await fetch(`${a}/yeast-strains/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete yeast strain: ${e.statusText}`)}async function W(){const t=await fetch(`${a}/yeast-strains/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh yeast strains: ${t.statusText}`);return t.json()}async function z(t){const e=new URLSearchParams;t?.origin&&e.append("origin",t.origin),t?.purpose&&e.append("purpose",t.purpose),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/hop-varieties?${e}`);if(!n.ok)throw new Error(`Failed to fetch hop varieties: ${n.statusText}`);return n.json()}async function K(){const t=await fetch(`${a}/hop-varieties/origins`);if(!t.ok)throw new Error(`Failed to fetch hop origins: ${t.statusText}`);return t.json()}async function Q(t){const e=await fetch(`${a}/hop-varieties`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create hop variety: ${e.statusText}`);return e.json()}async function X(t){const e=await fetch(`${a}/hop-varieties/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete hop variety: ${e.statusText}`)}async function Z(){const t=await fetch(`${a}/hop-varieties/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh hop varieties: ${t.statusText}`);return t.json()}async function tt(t){const e=new URLSearchParams;t?.type&&e.append("type",t.type),t?.origin&&e.append("origin",t.origin),t?.maltster&&e.append("maltster",t.maltster),t?.search&&e.append("search",t.search),t?.is_custom!==void 0&&e.append("is_custom",String(t.is_custom)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/fermentables?${e}`);if(!n.ok)throw new Error(`Failed to fetch fermentables: ${n.statusText}`);return n.json()}async function et(){const t=await fetch(`${a}/fermentables/types`);if(!t.ok)throw new Error(`Failed to fetch fermentable types: ${t.statusText}`);return t.json()}async function nt(){const t=await fetch(`${a}/fermentables/origins`);if(!t.ok)throw new Error(`Failed to fetch fermentable origins: ${t.statusText}`);return t.json()}async function at(){const t=await fetch(`${a}/fermentables/maltsters`);if(!t.ok)throw new Error(`Failed to fetch maltsters: ${t.statusText}`);return t.json()}async function st(t){const e=await fetch(`${a}/fermentables`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error(`Failed to create fermentable: ${e.statusText}`);return e.json()}async function ot(t){const e=await fetch(`${a}/fermentables/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete fermentable: ${e.statusText}`)}async function rt(){const t=await fetch(`${a}/fermentables/refresh`,{method:"POST"});if(!t.ok)throw new Error(`Failed to refresh fermentables: ${t.statusText}`);return t.json()}async function it(t){const e=new URLSearchParams,n=await fetch(`${a}/inventory/equipment?${e}`);if(!n.ok)throw new Error(`Failed to fetch equipment: ${n.statusText}`);return n.json()}async function ct(t){const e=await fetch(`${a}/inventory/equipment`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create equipment")}return e.json()}async function ht(t,e){const n=await fetch(`${a}/inventory/equipment/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update equipment")}return n.json()}async function ft(t){const e=await fetch(`${a}/inventory/equipment/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete equipment: ${e.statusText}`)}async function pt(t){const e=new URLSearchParams,n=await fetch(`${a}/inventory/hops?${e}`);if(!n.ok)throw new Error(`Failed to fetch hop inventory: ${n.statusText}`);return n.json()}async function dt(){const t=await fetch(`${a}/inventory/hops/summary`);if(!t.ok)throw new Error(`Failed to fetch hop summary: ${t.statusText}`);return t.json()}async function ut(t){const e=await fetch(`${a}/inventory/hops`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create hop inventory")}return e.json()}async function wt(t,e){const n=await fetch(`${a}/inventory/hops/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update hop inventory")}return n.json()}async function lt(t,e){const n=await fetch(`${a}/inventory/hops/${t}/adjust`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({delta_grams:e})});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to adjust hop amount")}return n.json()}async function yt(t){const e=await fetch(`${a}/inventory/hops/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete hop: ${e.statusText}`)}async function $t(t){const e=new URLSearchParams;t?.query&&e.append("query",t.query),t?.form&&e.append("form",t.form),t?.include_expired!==void 0&&e.append("include_expired",String(t.include_expired)),t?.limit&&e.append("limit",String(t.limit)),t?.offset&&e.append("offset",String(t.offset));const n=await fetch(`${a}/inventory/yeast?${e}`);if(!n.ok)throw new Error(`Failed to fetch yeast inventory: ${n.statusText}`);return n.json()}async function mt(t=30){const e=await fetch(`${a}/inventory/yeast/expiring-soon?days=${t}`);if(!e.ok)throw new Error(`Failed to fetch expiring yeast: ${e.statusText}`);return e.json()}async function Tt(){const t=await fetch(`${a}/inventory/yeast/summary`);if(!t.ok)throw new Error(`Failed to fetch yeast summary: ${t.statusText}`);return t.json()}async function jt(t){const e=await fetch(`${a}/inventory/yeast`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to create yeast inventory")}return e.json()}async function Et(t,e){const n=await fetch(`${a}/inventory/yeast/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to update yeast inventory")}return n.json()}async function bt(t,e=1){const n=await fetch(`${a}/inventory/yeast/${t}/use`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({quantity:e})});if(!n.ok){const s=await n.json().catch(()=>({detail:n.statusText}));throw new Error(s.detail||"Failed to use yeast")}return n.json()}async function St(t){const e=await fetch(`${a}/inventory/yeast/${t}`,{method:"DELETE"});if(!e.ok)throw new Error(`Failed to delete yeast: ${e.statusText}`)}async function gt(t){const e=await fetch(`${a}/assistant/review-recipe`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok){const n=await e.json().catch(()=>({detail:e.statusText}));throw new Error(n.detail||"Failed to review recipe")}return e.json()}async function xt(t,e=10){const n=new URLSearchParams;n.append("q",t),n.append("limit",String(e));const s=await fetch(`${a}/recipes/styles/search?${n}`);if(!s.ok)throw new Error(`Failed to search styles: ${s.statusText}`);return s.json()}export{E as $,et as A,at as B,M as C,Q as D,st as E,G as F,X as G,ot as H,L as I,N as J,H as K,U as L,A as M,_ as N,R as O,B as P,g as Q,c as R,O as S,C as T,l as U,y as V,h as W,b as X,f as Y,p as Z,d as _,pt as a,j as a0,T as a1,F as a2,x as a3,J as a4,nt as a5,xt as a6,gt as a7,w as a8,u as a9,q as aa,D as ab,Y as ac,v as ad,k as ae,P as af,$ as ag,m as ah,dt as b,$t as c,Tt as d,mt as e,it as f,I as g,z as h,ct as i,wt as j,ut as k,lt as l,Et as m,jt as n,ft as o,yt as p,St as q,bt as r,S as s,W as t,ht as u,Z as v,rt as w,V as x,K as y,tt as z};
