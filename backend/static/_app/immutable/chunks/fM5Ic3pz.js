import{p as d}from"./TUuJpABw.js";const e=d({tilts:new Map,connected:!1,ambient:null,heater:{state:null,entity_id:null,last_changed:null,available:!1,loading:!1}});let o=null,l=null;async function h(){try{const a=await fetch("/api/devices/readings/latest");if(a.ok){const n=await a.json();for(const[c,t]of Object.entries(n))e.tilts.set(c,t);e.tilts=new Map(e.tilts),console.log(`Loaded ${Object.keys(n).length} cached readings`)}}catch(a){console.warn("Failed to fetch cached readings:",a)}}function f(){if(o?.readyState===WebSocket.OPEN)return;const n=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}/ws`;console.log("Connecting to WebSocket:",n),o=new WebSocket(n),o.onopen=async()=>{console.log("WebSocket connected"),e.connected=!0,l&&(clearTimeout(l),l=null),await h()},o.onmessage=c=>{try{const t=JSON.parse(c.data);if(t.type==="ambient"){e.ambient={temperature:t.temperature,humidity:t.humidity,timestamp:t.timestamp};return}if(t.type==="control_event"){t.action==="heat_on"?(e.heater.state="on",e.heater.last_changed=t.timestamp):t.action==="heat_off"&&(e.heater.state="off",e.heater.last_changed=t.timestamp);return}const i=t;e.tilts.set(i.id,i),e.tilts=new Map(e.tilts)}catch(t){console.error("Failed to parse WebSocket message:",t)}},o.onclose=()=>{console.log("WebSocket disconnected"),e.connected=!1,o=null,l=setTimeout(f,3e3)},o.onerror=c=>{console.error("WebSocket error:",c),o?.close()}}function p(){l&&(clearTimeout(l),l=null),o?.close(),o=null}let s=null;async function r(){try{e.heater.loading=!0;const a=await fetch("/api/control/heater");if(a.ok){const n=await a.json();e.heater.state=n.state,e.heater.entity_id=n.entity_id,e.heater.last_changed=n.last_changed,e.heater.available=n.available}}catch(a){console.error("Failed to fetch heater state:",a)}finally{e.heater.loading=!1}}function g(a=3e4){r(),s&&clearInterval(s),s=setInterval(r,a)}function m(){s&&(clearInterval(s),s=null)}export{m as a,f as c,p as d,g as s,e as t};
